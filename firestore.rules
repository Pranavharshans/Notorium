rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isUserAuthorized(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isValidPaymentAmount(amount) {
      return amount is number && amount > 0;
    }

    function isValidPaymentStatus(status) {
      return status in ['succeeded', 'failed', 'pending', 'refunded'];
    }

    function isValidPaymentIntentStatus(status) {
      return status in ['requires_payment_method', 'requires_confirmation', 'succeeded', 'failed'];
    }

    function isValidSubscriptionStatus(status) {
      return status in ['active', 'cancelled', 'expired'];
    }

    function isValidSubscriptionTier(tier) {
      return tier in ['free', 'pro'];
    }

    // Basic user document rules
    match /users/{userId} {
      allow read: if isUserAuthorized(userId);
      allow write: if isUserAuthorized(userId);
    }

    // Subscription rules
    match /subscriptions/{userId} {
      allow read: if isUserAuthorized(userId);
      
      // Allow initial subscription creation
      allow create: if isUserAuthorized(userId)
        && isValidSubscriptionStatus(request.resource.data.status)
        && isValidSubscriptionTier(request.resource.data.tier)
        && request.resource.data.startDate is timestamp
        && (request.resource.data.endDate == null || request.resource.data.endDate is timestamp)
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      
      // Allow subscription updates with valid status changes
      allow update: if isUserAuthorized(userId)
        && isValidSubscriptionStatus(request.resource.data.status)
        && isValidSubscriptionTier(request.resource.data.tier)
        && request.resource.data.startDate is timestamp
        && (request.resource.data.endDate == null || request.resource.data.endDate is timestamp)
        && request.resource.data.updatedAt is timestamp;
    }
    
    // Quota tracking rules
    match /quotas/{userId} {
      allow read: if isUserAuthorized(userId);
      
      // Allow users to create their initial quota
      allow create: if isUserAuthorized(userId)
        && request.resource.data.recordingMinutesUsed == 0
        && request.resource.data.enhanceNotesUsed == 0
        && (request.resource.data.subscriptionStartDate is string || request.resource.data.subscriptionStartDate is timestamp)
        && request.resource.data.updatedAt is timestamp;
      
      // Allow users to update their own quota with valid increments
      allow update: if isUserAuthorized(userId)
        && (
          // Allow recording minutes increment
          (request.resource.data.recordingMinutesUsed > resource.data.recordingMinutesUsed 
           && request.resource.data.enhanceNotesUsed == resource.data.enhanceNotesUsed
           && request.resource.data.subscriptionStatus == resource.data.subscriptionStatus
           && (request.resource.data.subscriptionStartDate == resource.data.subscriptionStartDate || request.resource.data.subscriptionStartDate is timestamp))
          ||
          // Allow enhance notes increment
          (request.resource.data.enhanceNotesUsed > resource.data.enhanceNotesUsed 
           && request.resource.data.recordingMinutesUsed == resource.data.recordingMinutesUsed
           && request.resource.data.subscriptionStatus == resource.data.subscriptionStatus
           && (request.resource.data.subscriptionStartDate == resource.data.subscriptionStartDate || request.resource.data.subscriptionStartDate is timestamp))
          ||
          // Allow subscription status and date update
          (request.resource.data.subscriptionStatus != resource.data.subscriptionStatus
           && request.resource.data.recordingMinutesUsed == resource.data.recordingMinutesUsed
           && request.resource.data.enhanceNotesUsed == resource.data.enhanceNotesUsed
           && (request.resource.data.subscriptionStartDate is string || request.resource.data.subscriptionStartDate is timestamp))
        )
        && request.resource.data.updatedAt is timestamp;
    }

    // Payment history rules
    match /payments/{userId}/history/{paymentId} {
      allow read: if isUserAuthorized(userId);
      allow create: if isUserAuthorized(userId)
        && isValidPaymentAmount(request.resource.data.amount)
        && isValidPaymentStatus(request.resource.data.status)
        && request.resource.data.createdAt is timestamp;
      allow update: if false; // Payment history should be immutable
      allow delete: if false; // Payment history cannot be deleted
    }

    // Payment intents rules
    match /payments/{userId}/intents/{intentId} {
      allow read: if isUserAuthorized(userId);
      allow create: if isUserAuthorized(userId)
        && isValidPaymentAmount(request.resource.data.amount)
        && isValidPaymentIntentStatus(request.resource.data.status)
        && request.resource.data.createdAt is timestamp;
      allow update: if isUserAuthorized(userId)
        && isValidPaymentIntentStatus(request.resource.data.status)
        && request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['status', 'errorMessage', 'updatedAt']);
      allow delete: if false; // Payment intents should not be deleted
    }

    // Notes collection rules
    match /notes/{noteId} {
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Default deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}